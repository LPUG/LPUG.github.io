<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="../static/style.css">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono|Lato:400,700|Roboto+Slab:400,700" rel="stylesheet">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/monokai-sublime.min.css">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Archive — lpug.github.io</title>
</head>
<body class="base-font-size">
  <div class="base-container">
  <header>
    <a href="/">
      <img class="logo" src="/static/logo.svg" alt="Leipzig Python User Group Logo">
    </a>
    <nav>
      <ul class="nav navbar">
        
        <li class="active">
          <a href="../">Willkommen</a>
        </li>
        
        <li class="active">
          <a href="../archive/">Archiv</a>
        </li>
        
        <li>
          <a href="../about/">Über uns</a>
        </li>
        
        
        <li>
          <a href="https://www.meetup.com/de-DE/Leipzig-Python-User-Group/" target="_blank">Meetup</a>
        </li>
        
        <li>
          <a href="https://github.com/LPUG" target="_blank">GitHub</a>
        </li>
        
      </ul>
    </nav>
  </header>
  <div class="page">
    
  <h2>Archive</h2>
  <p>Bisherige Präsentationen und Themen.</p>
<h1>12. Januar 2021, 19:00 Uhr (<a href="https://bbb.python-academy.de/b/mik-hct-ymm">BBB-Raum</a> ab 18:45 Uhr geöffnet)</h1>
<h1>Große Datenmengen in Videos animieren mit "bewegung"</h1>
<h2>Sebastian M. Ernst</h2>
<ul>
<li>Wie erstellt man <em>animierte</em> Visualisierungen (mit Python)?</li>
<li><a href="https://bewegung.readthedocs.io/en/develop/about.html#similar-alternative-libraries">Was für Bibliotheken bzw. Pakete gibt es - mit denen man auch Videos generieren kann?</a>?</li>
<li>Einführung zu und kleine Probier- und Bastel-Runde mit <strong>bewegung</strong>, einer neuen Bibliothek zur animierten Darstellung größerer Datenmengen:<ul>
<li><a href="https://github.com/pleiszenburg/bewegung">Github-Repositorium</a></li>
<li><a href="https://bewegung.readthedocs.io">Dokumentation bei RtD</a></li>
<li><a href="https://bewegung.readthedocs.io/en/develop/installation.html">Installation</a>: <a href="https://anaconda.org/conda-forge/bewegung"><img src="https://img.shields.io/conda/vn/conda-forge/bewegung.svg?style=flat-square" alt="conda_version" title="conda version"></a> &amp; <a href="https://pypi.python.org/pypi/bewegung"><img src="https://img.shields.io/pypi/pyversions/bewegung.svg?style=flat-square" alt="pypi_versions" title="Available on PyPi - the Python Package Index"></a></li>
</ul>
</li>
</ul>
<blockquote><p><code>bewegung</code> is a versatile video renderer, primarily targeting scientific visualizations of large quantities of data. Its core concepts are <em>sequences</em> and <em>layers</em>. Sequences describe a certain time span within a video and can overlap. Each sequence can hold multiple layers. Layers can be generated with <a href="https://cairographics.org/"><code>cairo</code></a>, <a href="https://pillow.readthedocs.io"><code>Pillow</code></a>, <a href="https://datashader.org/"><code>datashader</code></a>, <a href="https://matplotlib.org/"><code>matplotlib</code></a> and <code>bewegung</code>'s internal drawing system <a href="https://bewegung.readthedocs.io/en/latest/canvas.html"><code>DrawingBoard</code></a>. Final compositing of every video frame and video effects are implemented via <code>Pillow</code>. Video encoding is handled by <code>ffmpeg</code>. <code>bewegung</code> also includes a simple <a href="https://bewegung.readthedocs.io/en/latest/vectors.html">vector algebra system</a> and a <a href="https://bewegung.readthedocs.io/en/latest/camera.html">"camera" for 3D to 2D projections</a>. <code>bewegung</code> is developed with ease of use, compute time and memory efficiency in mind.</p>
</blockquote>
<h1>8. Dezember 2020</h1>
<h1>Web APIs mit Django und GraphQL</h1>
<h2>Andreas Bamberger</h2>
<p>Vortragsinhalt:</p>
<ul>
<li>Was ist GraphQL?<ul>
<li>Hintergründe und Konzepte</li>
<li>Vor &amp; Nachteile gegenüber REST</li>
</ul>
</li>
<li>Vorstellung einer Referenzimplementierung mittels Graphene-Django</li>
</ul>
<p>Präsentation und Code: <a href="https://gitlab.com/a_ba/lpug-django-graphene">https://gitlab.com/a_ba/lpug-django-graphene</a></p>
<h1>10.11.2020</h1>
<h1>Diskussionsrunde - "Was mich an besonders Python stört, was mir an Python besonders gefällt."</h1>
<p>Wir haben uns online getroffen und intensiv diskutiert.
Dabei kamen Merkmale von Python, die wir besonders mögen oder die uns besonders
stören zur Sprache.
Es gab verschiedene Meinungen zu ein paar Themen, so dass man viel lernen
konnte.</p>
<h1>13.10.2020</h1>
<h1>Einfache Web-Anwendungen mit Flask</h1>
<h2>Lukas Werner</h2>
<p>Die kleine Einführung in das Web Framework Flask ging auf folgende Punkte ein:</p>
<ul>
<li>Aufsetzen einer Flask-Anwendung</li>
<li>Routing &amp; Templating (Jinja2)</li>
<li>Requests und Responses</li>
<li>Produktivsetzen einer Flask Anwendung mittels uWSGI</li>
<li>ggf. Sessions/Flashing</li>
<li>Einsatzmöglichkeiten im Data-Science-Sektor</li>
</ul>
<p>Da jeder der Punkte eine eigene Vorstellung ausfüllen könnte, hat der Vortrag die meisten Punkte nur kurz umrissen. Einen großen Teil der Vortragszeit hat die Diskussion zum Thema eingenommen.</p>
<h1>08.09.2020</h1>
<h1>Was ist neu in Python 3.9</h1>
<p>Die neue Python-Version wird bald verfügbar sein. Deshalb haben wir uns angesehen was Python 3.9 an neuen Merkmalen bietet.</p>
<p>Es gab wieder viele interessante Diskussionen zu verschiedensten Themen um Python und Softwareentwicklung. Wir hatten viele Erst-Teilnehmer, die sich rege an der Diskussion beteiligten.</p>
<h1>11.08.2020</h1>
<h1>Die Programmiersprache Nim aus Python-Sicht - Ein Erfahrungsbericht</h1>
<h2>Stefan Schwarzer</h2>
<p>Als langjähriger Python-Entwickler bin ich auf der Suche nach einer flexiblen statisch typisierten Programmiersprache vor einem Jahr auf Nim ( <a href="https://nim-lang.org">https://nim-lang.org</a> ) gekommen.</p>
<p>Ich möchte euch etwas über die Sprache erzählen, unter anderem über besondere Unterschiede zu Python und wie man beide Sprachen kombinieren kann. Ich habe darüber hinaus einiges an Material, aber wir müssen nicht alles strikt durchgehen, denn ein User-Group-Treffen lebt ja auch von der Diskussion. :-)</p>
<h1>14.07.2020</h1>
<h1>Hardware mit Python ansteuern</h1>
<h2>Andre Bunk</h2>
<p>Andre stellte sein Projekt vor.
Das sind die wichtigsten Punkte:</p>
<ol>
<li>Pumpensteuerung für den Garten</li>
<li>Temperaturmessung mit TC74</li>
<li>Speichern dieser Messdaten mit SQLite</li>
<li>Auswertung von Textdateien des Mediathekview mit Python</li>
<li>Auswertung der gemessenen Temperaturwerte</li>
<li>Benutzung-Schnittstelle mit tkinter geplant</li>
</ol>
<p>Die Quelltexte stehen zur Verfügung:</p>
<p>FTP: odroid.home-webserver.de <br>
Nutzer: gast <br>
Passwort: gastgast1 <br></p>
<h1>12.05.2020</h1>
<h1>Online-Treffen</h1>
<h1>Programming Guidelines</h1>
<h2>Thomas Güttler</h2>
<p>Mit 13 Jahren habe ich das Programmieren angefangen und bin nun 43.</p>
<p>Seit dem habe ich sehr viele Fehler gemacht und habe daraus
mehr oder weniger viel gelernt.</p>
<p>Seit einer Weile schreibe ich meine persönlichen Programming Guidelines
auf. Zum einen um mehr Klarheit über mein eigenes Handeln zu finden.
Zum anderen , um dem einen oder anderen Neueinsteiger ein paar Irrwege
zu ersparen.</p>
<p>Der Text ist auf englisch und hier zu finden:</p>
<p><a href="https://github.com/guettli/programming-guidelines">https://github.com/guettli/programming-guidelines</a></p>
<h1>14.01.2020</h1>
<h1>Python-Konferenzen 2020</h1>
<p>Mittlerweile gibt es im Prinzip jede Woche ein oder mehrere Python-Konferenzen
irgendwo auf der Welt.
Welche Python-Konferenzen sind besonders interessant?
Wie läuft eine solche Konferenz ab?
Lohnt es sich teilzunehmen?
Wenn, ja warum?
Mike Müller gab persönliche Eindrücke von ein paar Python-Konferenzen der
letzten Jahre und versuchte damit diese Fragen zu beantworten.
Das ist natürlich subjektiv und auf wenige Konferenz beschränkt.
Trotzdem könnte es bei der Entscheidung helfen eine Python-Konferenzen zu
besuchen und dann die richtige auszusuchen.</p>
<h1>13.08.2019</h1>
<h1>Fortran-Bibliotheken in Python nutzen</h1>
<h2>Mike Müller</h2>
<p>Viele wissenschaftliche Anwendungen sind in Fortran implementiert.
Es ist wahrscheinlich die älteste Hochsprache, die noch relativ weit verbreitet
ist.
Für numerische Anwendungen kann Fortran-Code durchaus beträchtlich schnellere
Programme ergeben als Code in C oder ähnlichen Sprachen.
Für andere Programmieraufgaben als numerische Algorithmen ist Fortran
allerdings nicht so gut geeignet.
Hier kommen die Fähigkeiten von Python ins Spiel Quelltext anderer
Programmiersprachen relativ einfach als sogenannten Erweiterungen in Python
integrieren zu können.</p>
<p>Dieser Vortrag stellt das Werkzeug <code>f2py</code> vor.
Damit lassen sich Fortran-Quelltext elegant in Python-Erweiterungen einbauen.
Der Zugriff auf Fortran-Arrays, die in Fortran-Modulen liegen ist mit
NumPy-Arrays von Python aus nahtlos möglich.
Oft sind Fortran-Quelltexte sehr monolithisch mit einer großen Schleifen für
Simulations-Zeitschritte aufgebaut.
Der Vortrag zeigt wie sich mit Hilfe von Callbacks und Threads Erweiterungen
bauen lassen, die die Eingriffe in diese monolithische Struktur auf ein Minimum
beschränken.
Eine Demo zeigt wie sich in einem Jupyter-Notebook Fortran-Variablen live von
Python aus anzeigen und verändern lassen.</p>
<p>Keine Angst: Fortran-Wissen ist nicht nötig, um dem Vortrag folgen zu können.
Solide Python-Kenntnisse sind ausreichend.
Sogar ohne Python-Wissen sollten die Grundprinzipien zu verstehen sein.</p>
<hr>
<h1>10.09.2019</h1>
<h1>Programming Guidelines</h1>
<h2>Thomas Güttler</h2>
<p>Mit 13 Jahren habe ich das Programmieren angefangen und bin nun 43.</p>
<p>Seit dem habe ich sehr viele Fehler gemacht und habe daraus
mehr oder weniger viel gelernt.</p>
<p>Seit einer Weile schreibe ich meine persönlichen Programming Guidelines
auf. Zum einen um mehr Klarheit über mein eigenes Handeln zu finden.
Zum anderen , um dem einen oder anderen Neueinsteiger ein paar Irrwege
zu ersparen.</p>
<p>Der Text ist auf englisch und hier zu finden:</p>
<p><a href="https://github.com/guettli/programming-guidelines">https://github.com/guettli/programming-guidelines</a></p>
<hr>
<h1>Treffen am 11. Oktober 2018 19:00 Uhr</h1>
<p>Robert Lieback sprach über "Desktop-Anwendungen mit PyQt5 und PyInstaller"</p>
<p>Best-Practices für die Desktopentwicklung: Vom Qt-Designer, über das Event-Management, zur Distribution mit PyInstaller.</p>
<hr>
<h1>Treffen am 08. Mai 2018 19:00 Uhr</h1>
<p>Sebastian Ernst über das Thema <em>Zahlen stapeln mit HDF5 (h5py), Bcolz &amp; Zarr</em>
gesprochen.</p>
<hr>
<h1>Treffen am 08. Mai 2018 19:00 Uhr</h1>
<p>Markus Zapke-Gründemann sprach über "Can packaging improve Django deployments?"</p>
<p>How can packaging Django projects make deployments easier, faster and more reliable?</p>
<p>This is a preview of Markus' talk at DjangoCon Europe 2018 in Heidelberg. The talk will be held in English.</p>
<p>Es waren 13 Personen anwesend. Nach dem Vortrag gab es eine lebhafte Diskussion zum Thema Deployment von Django Projekten. Außerdem wurde das Thema Packaging weiter vertieft.</p>
<hr>
<h1>Treffen am 10. April 2018 19:00 Uhr</h1>
<p>Andreas Linz sprach über "Think DSP - Digital Signal Processing in Python".</p>
<p>Der Vortrag war eine Zusammenfassung des Open-Source Buches <a href="https://github.com/AllenDowney/ThinkDSP">ThinkDSP</a> von Allen Downey und gleichzeitig eine Einführung in die Grundlagen der (Audio-)Signalverarbeitung.</p>
<p>Zu dem Buch gibt es eine Reihe von <a href="http://mybinder.org/repo/AllenDowney/ThinkDSP">Jupyter Notebooks</a>, die die vorgestellten Konzepte veranschaulichen.</p>
<p>Mit 17 Anwesenden war der Vortrag sehr gut besucht.</p>
<hr>
<h1>Treffen am 13. Februar 2018 19:00 Uhr</h1>
<p>Unser Vortrag war diesmal:</p>
<p><em>Martin Czygan</em></p>
<p><strong>Deep Learning with PyTorch</strong></p>
<p>PyTorch is a machine learning framework, with focus on deep neural
nets. PyTorch is sometimes regarded as the most pythonic among the
current generation of such tools.</p>
<p>We briefly introduce the problems deep learning tries to solve; then
we take a look at PyTorch and it's pythonic approach.</p>
<p>Repository with slides and notebooks:</p>
<ul>
<li><a href="https://github.com/miku/pytorch-tour">https://github.com/miku/pytorch-tour</a></li>
</ul>
<hr>
<h1>Gemütliches Weihnachtstreffen am 12.12.2017 19:00 Uhr</h1>
<p>Das letzte LPUG-Treffen im Jahr 2017 haben wir im Rahmen der
Weihnachtszeit in gemütlicher Runde zum freien Plausch genutzt.
Weiterhin haben über mögliche Inhalte im nächsten Jahr und die zukünftige
Gestaltung der LPUG gesprochen.</p>
<h2>Struktur der LPUG in 2018</h2>
<h3>grobe Jahresplanung</h3>
<p>Unser Ziel ist es, zwei symmetrische Halbjahre aufzubauen.
Über das Jahr verteilt könnten dann u.a. folgende Themenblöcke als Inhalt
fungieren:</p>
<ul>
<li>2 x coding dojo inkl. TDD</li>
<li>2 x große talks</li>
<li>2 x code review</li>
<li>lightning talks</li>
<li>Problem mitbringen/ Erfahrungsbericht</li>
</ul>
<h3>Planungsstufen</h3>
<p>Um die Mitarbeit zu motivieren und besser planbar zu gestalten, haben wir
verschiedene Planungsstufen.</p>
<h4>1. konkret (Thema, Person, Datum)</h4>
<ul>
<li>PyTorch, Martin Czygan, Feb</li>
<li>Rust, Andreas, Mrz</li>
<li>Docker, Markus Zapke-Gründemann, Mai</li>
<li>HDF5, Sebastian Ernst, Jul</li>
</ul>
<h4>2. in Planung (Thema, Person)</h4>
<ul>
<li>Aufbau jupyter, Martin Czygan + jupyter Beispiele, Philipp Hanemann</li>
<li>home automation, Maik Derstappen</li>
<li>Programmierparadigmen, Martin</li>
<li>desktop applications, Robert</li>
</ul>
<h4>3. interessant (Thema)</h4>
<ul>
<li>code analyse<ul>
<li>antipattern</li>
<li>error handling</li>
<li>testing</li>
</ul>
</li>
<li>plotting</li>
<li>distributed computing</li>
<li>crawler: scrappy/ beautiful soup</li>
<li>project euler</li>
<li>Micro Python</li>
<li>Webentwicklung</li>
</ul>
<h1>Treffen am 12. September 2017 19:00 Uhr</h1>
<h2>How to Create a Python Package and Write Reusable Code</h2>
<p><em>Philipp Hanemann</em></p>
<p>Python wird von vielen Nutzern wertgeschätzt, weil sie mit dieser Programmiersprache sehr produktiv sind.
Von der Idee bis zur Umsetzung sind oftmals nur wenige, aber dennoch gut lesbare Zeilen Code notwendig.
Dies ist vor allem in der Reichhaltigkeit der vorhandenen Bibliotheken begründet.
Diese bündeln in der Regel Funktionen und Klassen mit einem bestimmten thematischen Fokus und stellen damit wiederverwertbaren Code dar.
Einmal installiert, kann der Nutzer auf die Werkzeuge der Bibliothek bequem zugreifen.</p>
<p>Glücklicherweise ist der Aufwand eine eigene Bibliothek zu bauen unwesentlich höher als einfache Skripte zu schreiben.
Nichtsdestotrotz gibt es für ein strukturelles einiges zu beachten.</p>
<p>Der Vortrag zeigt wie robuster und wiederverwertbarer Code entsteht.
Die Präsentation stellt ein paar Konzepte vor und bereitet den danach folgenden interaktiven Erfahrungsaustausch vor.</p>
<h1>Treffen am 8. August 2017 19:00 Uhr</h1>
<p>Wir haben unser erstes <a href="http://codingdojo.org/WhatIsCodingDojo/">Coding Dojo</a>
durchgeführt.
Ein Dojo besteht aus Programmierübungen, sogenannte Katas, für kleine,
in sich abgeschlossene Probleme.
Dazu haben wir Paare gebildet.
Ein Ziel der Übungen  war es Test-Driven-Development (TDD) zu trainieren,
also die Tests vor der Implementierung zu schreiben.
Ähnlich wie bei Katas im Kampfsport geht es primär darum grundsätzliche
Fähigkeiten zu internalisieren.</p>
<h2>Unsere Kata</h2>
<h3>Problem</h3>
<p>Wir haben uns die
<a href="http://ccd-school.de/coding-dojo/function-katas/russische-bauernmultiplikation/">Russische Bauernmultiplikation</a> heraus gesucht:</p>
<p>Schreibe eine Funktion, die zwei ganze Zahlen mit dem Algorithmus
„russische Bauernmultiplikation“ multipliziert.</p>
<p>Die Signatur der Methode sieht wie folgt aus:</p>
<pre><code class="lang-python">mul(int: x, int: y) --&gt; int:
    # your code here
</code></pre>
<p>Der Algorithmus der sogenannten Russischen Bauernmultiplikation verläuft wie
folgt:
man halbiert die linke der beiden Zahlen so lange, bis die 1 erreicht ist.
Nachkommastellen werden abgerundet.
Die rechte Zahl wird jeweils daneben geschrieben und verdoppelt.
Von den rechten Zahlen werden alle gestrichen, neben denen links eine gerade
Zahl steht.
Die verbleibenden nicht gestrichenen Zahlen der rechten Seite werden dann
addiert und bilden das Ergebnis der Multiplikation.</p>
<p>Beispiel:</p>
<pre><code>47 *  42
--------
47    42
23    84
11   168
 5   336
 2  (672)  # deleted because 2 ist even)
 1  1344
========
    1974
</code></pre>
<p>Das geht natürlich auch einfacher:</p>
<pre><code class="lang-python">&gt;&gt;&gt; 47 *  42
1974
</code></pre>
<h2>Lösungen</h2>
<h3>Iterative Lösung</h3>
<p>Die Summe ist zu Beginn Null <code>sum_ = 0</code>.
Wenn der erste Wert negativ ist, kehren wir einfach die Vorzeichen
der beiden Zahlen um.
Damit decken wir auch negative Zahlen ab.
Solange der erste Wert größer Null ist (<code>while x &gt; 0:</code>),
summieren wir auf.
Aber nur wenn der erste Wert gerade ist: <code>if x % 2:</code>.
Der erste Wert wird mit Integer-Divison halbiert <code>x = x // 2</code>
und der zweite verdoppelt <code>y = y * 2</code>.</p>
<pre><code class="lang-python">def mul(x, y):
    sum_ = 0
    if x &lt; 0:
        x, y = -x,  -y
    while x &gt; 0:
        if x % 2:
            sum_ += y
        x, y = x // 2, y * 2
    return sum_
</code></pre>
<h3>Lösung mit Generator</h3>
<p>Das ist eine Variation der obigen iterativen Lösung.
Anstatt der Summierung geht zu addierende Wert mit <code>yield</code>
bei jedem Iterationsschritt raus.
Das finale <code>sum()</code> konsumiert den Generator, den die Generatorfunktion <code>get()</code>
zurück gibt.</p>
<pre><code class="lang-python">def get(x, y):
    if x &lt; 0:
        x, y = -x,  -y
    while x &gt; 0:
        if x % 2:
            yield y
        x, y = x // 2, y * 2

def mul2(x, y):
    return sum(v for v in get(x, y))
</code></pre>
<h3>Einfache Rekursive Lösung</h3>
<p>Rekursiver Ansatz: Das Problem wird beschrieben als eine Kaskade von
Referenzen auf "kleinere" Instanzen des selben Problems.  Die Kaskade
mündet in einen trivialen Sonderfall, für den eine direkte Lösung
angegeben wird.  Bei rekursiven Lösungen muss darauf geachtet werden,
dass die Abfolge von Referenzen stets gegen den trivialen Sonderfall
konvergiert.</p>
<p>Die erste Zeile im Rumpf fängt hier den Sonderfall <code>x == 0</code> ab.  Das ist
allgemeiner als gefordert.  Strikt nach Aufgabenstellung würde schon der
Sonderfall <code>x == 1</code> genügen; dann würden wir <code>y</code> statt <code>0</code> zurückgeben.
Das würde i.A. genau so gut funktionieren, aber das Programm würde dann
bei der Multiplikation mit einer linksseiten <code>0</code> nicht terminieren.</p>
<p>Die zweite Zeile im Rumpf übersetzt Aufrufe mit einem negativen Argument
für <code>x</code> in arithmetisch gleichwertige Aufrufe mit positivem <code>x</code> (siehe
dritte Zeile).  Auch das ist allgemeiner als gefordert.  Ohne diese
Zeile terminiert das Programm nur für nicht-negative <code>x</code>.</p>
<p>Die dritte Zeile im Rumpf realisiert die eigentlichen Zwischenschritte
der Bauernmultiplikation.  Der rekursive Aufruf entspricht dabei dem
Aufaddieren der darüberliegenden Summanden in der Tabelle.  Der aktuelle
Summand bleibt unberücksichtigt wenn <code>x</code> gerade ist (<code>x % 2 == 0</code>).</p>
<p>Konvergenz ist dadurch garantiert, dass die dritte Zeile im Rumpf <code>mul</code>
stets mit einem betraglich kleineren <code>x</code> aufruft, so dass der Sonderfall
<code>x == 0</code> früher oder später erreicht wird.</p>
<pre><code class="lang-python">def mul(x, y):
    if x == 0:
        return 0
    if x &lt; 0:
        return mul(-x, -y)
    return (0 if x % 2 == 0 else y) + mul( x//2, y*2 )
</code></pre>
<h1>13. Juni 2017 um 19:00 Uhr</h1>
<p>Wir hatten einen interessanten Vortrag:</p>
<p><strong>Cython</strong></p>
<p><em>Stefan Behnel</em></p>
<p>Cython ist ein optimierender statischer Complier für Python, der das
Erstellen von C-Erweiterungen für Python erleichtert.
Als Quelle kann (1) reines Python, (2) Python mit Typ-Deklarationen
(Cython-spezifisch) oder (3) C-Quelltext dienen.</p>
<p>Der Cython-Kern-Entwickler Stefan Behnel stellte Cython vor.
Er zeigte an praktischen Beispielen wie leicht es ist mit Cython zu arbeiten.
Er beantwortete tiefgehende Fragen zu Anwendung und Funktionsweise von Cython.</p>
<h1>11. April 2017 um 19:00 Uhr</h1>
<p>Diesmal hatten wir wieder eine freie Diskussion zu Pythonthemen.</p>
<h1>14. März 2017 um 19:00 Uhr</h1>
<p>Wir hatten einen Vortrag:</p>
<p>Mike Müller</p>
<p><strong>Statische Typisierung für Python</strong></p>
<p>Python ist eine dynamisch getypte Sprache.
Das wird auch in Zukunft so bleiben.
Mit <a href="http://mypy-lang.org/">mypy</a> und dem Modul <code>typing</code> der
Standardbibliothek ist es aber auch möglich statische Typen als Hinweise
hinzuzufügen.</p>
<p>Diese statischen Typen wertet Python zur Laufzeit <strong>nicht</strong> aus.
mypy arbeitet als Werkzeug mit dem Quelltext und überprüft die Richtigkeit
der Typen ähnlich wie ein Compiler bei statisch getypten Sprachen.
Der Vortrag stellte das generelle Vorgehen für die Nutzung der
optionalen statischen Typisierung mit mypy und die Neuerungen, die Python 3.6
hier mitbringt vor.</p>
<h1>14. Februar 2017 um 19:00 Uhr</h1>
<p>Diesmal hatten wir eine freie Diskussion zu Pythonthemen.
Wir haben uns geschaut welche neuen Bibliotheken in der letzten
Zeit erschien sind.</p>
<h1>10. Januar 2017 um 19:00 Uhr</h1>
<p>Unser Thema war diesmal die nebenläufige und parallele Programmierung.
Dabei haben wir uns vor allem mit den Unterschieden in den
Anwendungsfällen und der Programmierung mit <code>multiprocessing</code> und
<code>asyncio</code> beschäftigt.</p>
<p>Dazu haben wir mit Code-Beispielen gearbeitet, die zeigen, wie
sich mit diesen Methoden Rechenzeit einsparen lassen kann oder
eben nicht.</p>
<h1>13. Dezember 2016 um 19:00 Uhr</h1>
<p>Diesmal hatten ein vorweihnachtliches Treffen mit offenem Thema.
Wir diskutierten über die letzten Entwicklungen bei Python.
Dabei gab es immer neue Python-Bibliotheken zu entdecken.</p>
<h1>8. November 2016 um 19:00 Uhr</h1>
<p>Zum Treffen gab es einen Einführungsvortrag zu neuronalen Netzen. Theoretische
Hintergründe wurde skiziert und eine Reihe von Implementierungen in Python
vorgestellt: Basierend auf numpy, scikit-learn, tensorflow und keras. Die
Folien und Code sind <a href="https://github.com/miku/nntour">in diesem Repo zu finden</a>.
Die Präsentation mündete in eine Diskussion zu intelligenten Algorithmen im
Allgemeinen und auch ihre gesellschaftlichen Auswirkungen.</p>
<h1>09. August 2016</h1>
<h1>Rust for Pythonistas</h1>
<p>The slides are available at <a href="https://github.com/klingtnet/lpug-Rust?files=1">github</a> and <a href="http://www.slideshare.net/AndreasLinz1/rust-for-pythonistas-lpug?qid=8895be3c-0aa5-4555-917a-6d5fb6df6b8b&amp;v=&amp;b=&amp;from_search=1">slideshare</a>.</p>


  </div>
  <footer>
    <small>
      <p>Diese Seiten wurden mit <a href="https://www.getlektor.com/">Lektor</a> erstellt.</p>
    </small>
  </footer>
  </div>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/highlight.min.js"></script>
  <script async defer>hljs.initHighlightingOnLoad();</script>
</body>
</html>
